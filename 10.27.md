# 改造点（返回进度）

说明

```
step：只有状态（queued / in_progress / completed），不算百分比，但我们标注第几个正在进行的 step。

job：completed_steps / total_steps → job_progress_pct（0–100）。

run：对“当前可见的 jobs”计算 completed_jobs / total_jobs_visible → run_progress_pct（0–100）。

注意：因为有些 job 还没出现，这个百分比是动态上浮的，属于“准实时”。
step:job开始跑就有所有   
job：满足条件就会进执行队列可以看到，可能在workflow跑的过程中满足条件再加入

可以跑一遍下面的看看，job从3变为4了，因为两个都完成了integration前置条件才完成

```



```
无进度条格式（裸数据）：获取run_id   curl -s -X POST http://127.0.0.1:8000/api/cicd/run/  

                    轮询watch -n 5 curl -s http://127.0.0.1:8000/api/cicd/runs/RUN_ID
                    先获取此次的runid，下一个命令run_id改一下
```

```
以进度条显示  (先安装jq)  sudo apt-get update && sudo apt-get install -y jq

RUN_ID=$(curl -s -X POST http://127.0.0.1:8000/api/cicd/run/ | jq -r '.run_id'); echo "RUN_ID=$RUN_ID"

watch -n 2 "curl -s http://127.0.0.1:8000/api/cicd/runs/$RUN_ID/ \
| jq -r 'def repeat(n;s): reduce range(0;n) as \$i (\"\"; .+s);
         def bar(p): (if p<0 then 0 elif p>100 then 100 else p end) as \$p
                      | (\$p/5|floor) as \$f
                      | (20-\$f) as \$r
                      | \"[\"+repeat(\$f;\"#\")+repeat(\$r;\"-\")+\"] \"+(\$p|tostring)+\"%\";
         \"RUN  \" + bar(.run_progress_pct) + \" (\" + (.completed_jobs|tostring) + \"/\" + (.total_jobs_visible|tostring) + \" jobs)\",
         (.jobs[] | \" - \" + .job_name + \" \" + bar(.job_progress_pct) + \" [\" + .status + \"]\" +
                    (if .current_step_index != null then
                       \" step: \" + (.steps[.current_step_index].name)
                     else \"\"
                     end))'"
                     
                     
可以在后端显示进度条
```

问ai：意思就是我现在前端调用轮询watch -n 5 curl -s http://127.0.0.1:8000/api/cicd/runs/RUN_ID得到的数据在前端就可以处理了？

回答：对！就是这个意思 ✅

- 你前端只需要**定时请求**：`GET /api/cicd/runs/<RUN_ID>/`（比如每 2–5 秒一次）。
- API 返回里已经有：`run_progress_pct`、每个 job 的 `job_progress_pct`、steps 的 `status/is_current/is_done` 等。
- 前端拿到这些字段直接渲染进度条/高亮即可；

终端里的 `watch -n 5 curl ...` 只是方便你**在后端/本地调试**看到返回；在真正前端里就用上面的 fetch 轮询即可。

# 新加workflow功能

在主路由加

urlpatterns = [

... 其他

​    path("api/workflows/", include("taiga.workflows.urls")),
]





```
name: Demo CI Progress

on:
  workflow_dispatch:

jobs:
  alpha:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Alpha Step 1
        run: |
          for i in {1..3}; do
            echo "alpha step1 tick $i/3"
            sleep 2
          done

      - name: Alpha Step 2
        run: |
          for i in {1..3}; do
            echo "alpha step2 tick $i/3"
            sleep 2
          done

  beta:
    needs: alpha
    runs-on: ubuntu-latest
    steps:
      - name: Beta Step 1
        run: echo "beta start"

      - name: Beta Long Step
        run: |
          for i in {1..5}; do
            echo "beta long tick $i/5"
            sleep 2
          done

      - name: Beta Done
        run: echo "beta done"

```





把上面的内容保存为 `demo_progress.yml`放在workflows下



 上传到仓库（走你后端的 multipart 接口）

```
curl -v -X POST http://127.0.0.1:8000/api/workflows/ \
  -F "file=@demo_progress.yml" \
  -F "name=demo_progress.yml" \
  -F "branch=master"


```

